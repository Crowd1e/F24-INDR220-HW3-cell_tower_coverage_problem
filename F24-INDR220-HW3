{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 44,
   "id": "6a87b408-efe3-48a8-9c4d-25064738bb43",
   "metadata": {},
   "outputs": [],
   "source": [
    "# load libraries\n",
    "import numpy as np\n",
    "import scipy.sparse as sp\n",
    "\n",
    "import cplex as cp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "id": "c91e1512-d3bd-490f-b547-0a5ae8eec9b5",
   "metadata": {},
   "outputs": [],
   "source": [
    "def mixed_integer_linear_programming(direction, A, senses, b, c, l, u, types, names):\n",
    "    # create an empty optimization problem\n",
    "    prob = cp.Cplex()\n",
    "\n",
    "    # add decision variables to the problem including their coefficients in objective and ranges\n",
    "    prob.variables.add(obj = c.tolist(), lb = l.tolist(), ub = u.tolist(), types = types.tolist(), names = names.tolist())\n",
    "\n",
    "    # define problem type\n",
    "    if direction == \"maximize\":\n",
    "        prob.objective.set_sense(prob.objective.sense.maximize)\n",
    "    else:\n",
    "        prob.objective.set_sense(prob.objective.sense.minimize)\n",
    "\n",
    "    # add constraints to the problem including their directions and right-hand side values\n",
    "    prob.linear_constraints.add(senses = senses.tolist(), rhs = b.tolist())\n",
    "\n",
    "    # add coefficients for each constraint\n",
    "    row_indices, col_indices = A.nonzero()\n",
    "    prob.linear_constraints.set_coefficients(zip(row_indices.tolist(), col_indices.tolist(), A.data.tolist()))\n",
    "\n",
    "    print(prob.write_as_string())\n",
    "    # solve the problem\n",
    "    prob.solve()\n",
    "    \n",
    "    # check the solution status\n",
    "    print(prob.solution.get_status())\n",
    "    print(prob.solution.status[prob.solution.get_status()])\n",
    "\n",
    "    # get the solution\n",
    "    x_star = prob.solution.get_values()\n",
    "    obj_star = prob.solution.get_objective_value()\n",
    "\n",
    "    return(x_star, obj_star)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "id": "8297aa67-741f-415a-86ab-d0c0a7c5d71a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def cell_tower_coverage_problem(populations_file, T):\n",
    "    # your implementation starts below\n",
    "    populations = np.loadtxt(populations_file).astype(int)\n",
    "    H = populations.shape[0]\n",
    "    W = populations.shape[1]\n",
    "\n",
    "\n",
    "    c = np.concatenate((np.zeros(H * W),populations.flatten()))\n",
    "    b = np.concatenate((np.zeros(H * W), [T]))\n",
    "    senses = np.concatenate((np.full(H * W, \"G\"), [\"L\"]))\n",
    "    l = np.zeros(2 * H * W)\n",
    "    u = np.ones(2 * H * W)\n",
    "    types = np.full(2 * H * W, \"B\")\n",
    "    names = np.concatenate((np.array([f\"x_{h}_{w}\" for h in range(1, H + 1) for w in range(1, W + 1)]),\n",
    "                            np.array([f\"y_{h}_{w}\" for h in range(1, H + 1) for w in range(1, W + 1)])))\n",
    "\n",
    "    data, row, col = [], [], []\n",
    "\n",
    "    # 1st part: Main A matrix, selecting neighbours, finding column indexes, appending row, col, data values.\n",
    "    for i in range(H):\n",
    "        for j in range(W):\n",
    "            for di, dj in [(0, 0), (-1, 0), (1, 0), (0, -1), (0, 1)]:\n",
    "                ni, nj = i + di, j + dj\n",
    "                if 0 <= ni < H and 0 <= nj < W:\n",
    "                    x_index = ni * W + nj\n",
    "                    row.append(i * W + j)\n",
    "                    col.append(x_index)\n",
    "                    data.append(1)\n",
    "    \n",
    "    # 2nd part: Daigonally appending -1 * y{ij]\n",
    "    for i in range(H):\n",
    "        for j in range(W):\n",
    "            y_index = H * W + i * W + j\n",
    "            row.append(i * W + j)\n",
    "            col.append(y_index)\n",
    "            data.append(-1)\n",
    "            \n",
    "\n",
    "    \n",
    "    # 3rd part: All x variables summed up, \n",
    "    for x_index in range(H * W):\n",
    "        row.append(H * W)\n",
    "        col.append(x_index)\n",
    "        data.append(1)\n",
    "    \n",
    "    A = sp.csr_matrix((data, (row, col)), shape=(H * W + 1, 2 * H * W))\n",
    "    X_star, Obj_star = mixed_integer_linear_programming(\"maximize\", A, senses, b, c, l, u, types, names)\n",
    "    # your implementation ends above\n",
    "    return X_star"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2c11453c-ede2-4970-822e-c83c3b4c5acb",
   "metadata": {},
   "outputs": [],
   "source": [
    "dense_A = A.toarray()\n",
    "np.set_printoptions(threshold=np.inf, linewidth=np.inf)\n",
    "print(dense_A)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "2a57619b-fe28-474f-87d9-c1e2cf777e11",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Default row names c1, c2 ... being created.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\\ENCODING=ISO-8859-1\n",
      "\\Problem name: \n",
      "\n",
      "Maximize\n",
      " obj1: 732 y_1_1 + 539 y_1_2 + 949 y_1_3 + 508 y_1_4 + 806 y_1_5 + 881 y_1_6\n",
      "       + 646 y_2_1 + 757 y_2_2 + 257 y_2_3 + 630 y_2_4 + 994 y_2_5 + 547 y_2_6\n",
      "       + 105 y_3_1 + 859 y_3_2 + 876 y_3_3 + 589 y_3_4 + 615 y_3_5 + 345 y_3_6\n",
      "       + 136 y_4_1 + 370 y_4_2 + 433 y_4_3 + 419 y_4_4 + 631 y_4_5 + 485 y_4_6\n",
      "Subject To\n",
      " c1:  x_1_1 + x_1_2 + x_2_1 - y_1_1 >= 0\n",
      " c2:  x_1_1 + x_1_2 + x_1_3 + x_2_2 - y_1_2 >= 0\n",
      " c3:  x_1_2 + x_1_3 + x_1_4 + x_2_3 - y_1_3 >= 0\n",
      " c4:  x_1_3 + x_1_4 + x_1_5 + x_2_4 - y_1_4 >= 0\n",
      " c5:  x_1_4 + x_1_5 + x_1_6 + x_2_5 - y_1_5 >= 0\n",
      " c6:  x_1_5 + x_1_6 + x_2_6 - y_1_6 >= 0\n",
      " c7:  x_1_1 + x_2_1 + x_2_2 + x_3_1 - y_2_1 >= 0\n",
      " c8:  x_1_2 + x_2_1 + x_2_2 + x_2_3 + x_3_2 - y_2_2 >= 0\n",
      " c9:  x_1_3 + x_2_2 + x_2_3 + x_2_4 + x_3_3 - y_2_3 >= 0\n",
      " c10: x_1_4 + x_2_3 + x_2_4 + x_2_5 + x_3_4 - y_2_4 >= 0\n",
      " c11: x_1_5 + x_2_4 + x_2_5 + x_2_6 + x_3_5 - y_2_5 >= 0\n",
      " c12: x_1_6 + x_2_5 + x_2_6 + x_3_6 - y_2_6 >= 0\n",
      " c13: x_2_1 + x_3_1 + x_3_2 + x_4_1 - y_3_1 >= 0\n",
      " c14: x_2_2 + x_3_1 + x_3_2 + x_3_3 + x_4_2 - y_3_2 >= 0\n",
      " c15: x_2_3 + x_3_2 + x_3_3 + x_3_4 + x_4_3 - y_3_3 >= 0\n",
      " c16: x_2_4 + x_3_3 + x_3_4 + x_3_5 + x_4_4 - y_3_4 >= 0\n",
      " c17: x_2_5 + x_3_4 + x_3_5 + x_3_6 + x_4_5 - y_3_5 >= 0\n",
      " c18: x_2_6 + x_3_5 + x_3_6 + x_4_6 - y_3_6 >= 0\n",
      " c19: x_3_1 + x_4_1 + x_4_2 - y_4_1 >= 0\n",
      " c20: x_3_2 + x_4_1 + x_4_2 + x_4_3 - y_4_2 >= 0\n",
      " c21: x_3_3 + x_4_2 + x_4_3 + x_4_4 - y_4_3 >= 0\n",
      " c22: x_3_4 + x_4_3 + x_4_4 + x_4_5 - y_4_4 >= 0\n",
      " c23: x_3_5 + x_4_4 + x_4_5 + x_4_6 - y_4_5 >= 0\n",
      " c24: x_3_6 + x_4_5 + x_4_6 - y_4_6 >= 0\n",
      " c25: x_1_1 + x_1_2 + x_1_3 + x_1_4 + x_1_5 + x_1_6 + x_2_1 + x_2_2 + x_2_3\n",
      "      + x_2_4 + x_2_5 + x_2_6 + x_3_1 + x_3_2 + x_3_3 + x_3_4 + x_3_5 + x_3_6\n",
      "      + x_4_1 + x_4_2 + x_4_3 + x_4_4 + x_4_5 + x_4_6 <= 3\n",
      "Bounds\n",
      " 0 <= x_1_1 <= 1\n",
      " 0 <= x_1_2 <= 1\n",
      " 0 <= x_1_3 <= 1\n",
      " 0 <= x_1_4 <= 1\n",
      " 0 <= x_1_5 <= 1\n",
      " 0 <= x_1_6 <= 1\n",
      " 0 <= x_2_1 <= 1\n",
      " 0 <= x_2_2 <= 1\n",
      " 0 <= x_2_3 <= 1\n",
      " 0 <= x_2_4 <= 1\n",
      " 0 <= x_2_5 <= 1\n",
      " 0 <= x_2_6 <= 1\n",
      " 0 <= x_3_1 <= 1\n",
      " 0 <= x_3_2 <= 1\n",
      " 0 <= x_3_3 <= 1\n",
      " 0 <= x_3_4 <= 1\n",
      " 0 <= x_3_5 <= 1\n",
      " 0 <= x_3_6 <= 1\n",
      " 0 <= x_4_1 <= 1\n",
      " 0 <= x_4_2 <= 1\n",
      " 0 <= x_4_3 <= 1\n",
      " 0 <= x_4_4 <= 1\n",
      " 0 <= x_4_5 <= 1\n",
      " 0 <= x_4_6 <= 1\n",
      " 0 <= y_1_1 <= 1\n",
      " 0 <= y_1_2 <= 1\n",
      " 0 <= y_1_3 <= 1\n",
      " 0 <= y_1_4 <= 1\n",
      " 0 <= y_1_5 <= 1\n",
      " 0 <= y_1_6 <= 1\n",
      " 0 <= y_2_1 <= 1\n",
      " 0 <= y_2_2 <= 1\n",
      " 0 <= y_2_3 <= 1\n",
      " 0 <= y_2_4 <= 1\n",
      " 0 <= y_2_5 <= 1\n",
      " 0 <= y_2_6 <= 1\n",
      " 0 <= y_3_1 <= 1\n",
      " 0 <= y_3_2 <= 1\n",
      " 0 <= y_3_3 <= 1\n",
      " 0 <= y_3_4 <= 1\n",
      " 0 <= y_3_5 <= 1\n",
      " 0 <= y_3_6 <= 1\n",
      " 0 <= y_4_1 <= 1\n",
      " 0 <= y_4_2 <= 1\n",
      " 0 <= y_4_3 <= 1\n",
      " 0 <= y_4_4 <= 1\n",
      " 0 <= y_4_5 <= 1\n",
      " 0 <= y_4_6 <= 1\n",
      "Binaries\n",
      " x_1_1  x_1_2  x_1_3  x_1_4  x_1_5  x_1_6  x_2_1  x_2_2  x_2_3  x_2_4  x_2_5 \n",
      " x_2_6  x_3_1  x_3_2  x_3_3  x_3_4  x_3_5  x_3_6  x_4_1  x_4_2  x_4_3  x_4_4 \n",
      " x_4_5  x_4_6  y_1_1  y_1_2  y_1_3  y_1_4  y_1_5  y_1_6  y_2_1  y_2_2  y_2_3 \n",
      " y_2_4  y_2_5  y_2_6  y_3_1  y_3_2  y_3_3  y_3_4  y_3_5  y_3_6  y_4_1  y_4_2 \n",
      " y_4_3  y_4_4  y_4_5  y_4_6 \n",
      "End\n",
      "\n",
      "Version identifier: 22.1.1.0 | 2023-06-15 | d64d5bd77\n",
      "CPXPARAM_Read_DataCheck                          1\n",
      "Found incumbent of value 0.000000 after 0.00 sec. (0.00 ticks)\n",
      "Tried aggregator 1 time.\n",
      "Reduced MIP has 25 rows, 48 columns, and 148 nonzeros.\n",
      "Reduced MIP has 48 binaries, 0 generals, 0 SOSs, and 0 indicators.\n",
      "Presolve time = 0.00 sec. (0.08 ticks)\n",
      "Probing time = 0.00 sec. (0.01 ticks)\n",
      "Tried aggregator 1 time.\n",
      "Detecting symmetries...\n",
      "Reduced MIP has 25 rows, 48 columns, and 148 nonzeros.\n",
      "Reduced MIP has 48 binaries, 0 generals, 0 SOSs, and 0 indicators.\n",
      "Presolve time = 0.00 sec. (0.10 ticks)\n",
      "Probing time = 0.00 sec. (0.01 ticks)\n",
      "MIP emphasis: balance optimality and feasibility.\n",
      "MIP search method: dynamic search.\n",
      "Parallel mode: deterministic, using up to 4 threads.\n",
      "Root relaxation solution time = 0.00 sec. (0.14 ticks)\n",
      "\n",
      "        Nodes                                         Cuts/\n",
      "   Node  Left     Objective  IInf  Best Integer    Best Bound    ItCnt     Gap\n",
      "\n",
      "*     0+    0                            0.0000    14109.0000              --- \n",
      "*     0+    0                         4388.0000    14109.0000           221.54%\n",
      "*     0+    0                         7947.0000    14109.0000            77.54%\n",
      "*     0     0      integral     0     9583.0000     9583.0000       37    0.00%\n",
      "Elapsed time = 0.02 sec. (0.40 ticks, tree = 0.00 MB, solutions = 4)\n",
      "\n",
      "Root node processing (before b&c):\n",
      "  Real time             =    0.02 sec. (0.41 ticks)\n",
      "Parallel b&c, 4 threads:\n",
      "  Real time             =    0.00 sec. (0.00 ticks)\n",
      "  Sync time (average)   =    0.00 sec.\n",
      "  Wait time (average)   =    0.00 sec.\n",
      "                          ------------\n",
      "Total (root+branch&cut) =    0.02 sec. (0.41 ticks)\n",
      "101\n",
      "MIP_optimal\n",
      "[-0.0, 1.0, -0.0, 0.0, 0.0, -0.0, -0.0, 0.0, -0.0, -0.0, 1.0, 0.0, 0.0, 0.0, 1.0, -0.0, -0.0, 0.0, -0.0, 0.0, -0.0, -0.0, 0.0, -0.0, 1.0, 1.0, 1.0, -0.0, 1.0, -0.0, -0.0, 1.0, 1.0, 1.0, 1.0, 1.0, -0.0, 1.0, 1.0, 1.0, 1.0, -0.0, -0.0, -0.0, 1.0, -0.0, -0.0, -0.0]\n",
      "['x_1_1' 'x_1_2' 'x_1_3' 'x_1_4' 'x_1_5' 'x_1_6' 'x_2_1' 'x_2_2' 'x_2_3' 'x_2_4' 'x_2_5' 'x_2_6' 'x_3_1' 'x_3_2' 'x_3_3' 'x_3_4' 'x_3_5' 'x_3_6' 'x_4_1' 'x_4_2' 'x_4_3' 'x_4_4' 'x_4_5' 'x_4_6' 'y_1_1' 'y_1_2' 'y_1_3' 'y_1_4' 'y_1_5' 'y_1_6' 'y_2_1' 'y_2_2' 'y_2_3' 'y_2_4' 'y_2_5' 'y_2_6' 'y_3_1' 'y_3_2' 'y_3_3' 'y_3_4' 'y_3_5' 'y_3_6' 'y_4_1' 'y_4_2' 'y_4_3' 'y_4_4' 'y_4_5' 'y_4_6']\n"
     ]
    }
   ],
   "source": [
    "X_star = cell_tower_coverage_problem(\"populations.txt\", 3)\n",
    "print(X_star)\n",
    "H,W=4,6\n",
    "names = np.concatenate((np.array([f\"x_{h}_{w}\" for h in range(1, H + 1) for w in range(1, W + 1)]),\n",
    "                            np.array([f\"y_{h}_{w}\" for h in range(1, H + 1) for w in range(1, W + 1)])))\n",
    "print(names)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b1be55c4-3e47-47cd-88e4-6460a96fe06b",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "anaconda-2022.05-py39",
   "language": "python",
   "name": "conda-env-anaconda-2022.05-py39-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
